import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.io.File;
import java.io.FileNotFoundException; // Import this class to handle errors
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import com.google.protobuf.Message;
import io.grpc.Channel;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import kademlia_public_ledger.*;
import java.util.concurrent.TimeUnit;
import io.grpc.Server;
import io.grpc.ServerBuilder;
import java.net.URL;

class Public_ledger {

    private final Logger logger = Logger.getLogger(Public_ledger.class.getName());

    public static ArrayList<String> readFile() {
        ArrayList<String> content = new ArrayList<String>();
        try {
            File myObj = new File("ports_used.txt");
            Scanner myReader = new Scanner(myObj);
            while (myReader.hasNextLine()) {
                String data = myReader.nextLine();
                content.add(data);
                // System.out.println(data);
            }
            myReader.close();
        } catch (FileNotFoundException e) {
        System.out.println("An error occurred.");
        e.printStackTrace();
        }
        return content;
    }

    private void writeFile(String text) {
        try {
        FileWriter myWriter = new FileWriter("ports_used.txt", true);
        myWriter.write(text + "\n");
        myWriter.close();
        System.out.println("Successfully wrote to the file.");
        } catch (IOException e) {
        System.out.println("An error occurred.");
        e.printStackTrace();
        }
    }

    static int getPort() {
        ArrayList<String> file_content = new ArrayList<String>();
        file_content = readFile();
        int port;
        if(file_content.size()==0){
            port=50052;
        }
        else{
            port = Integer.parseInt(file_content.get(file_content.size() - 1)) + 1;
        }
        return port;
    }

    /*
        SERVER
    */
    private int port;
    private Server server;

    /** Start serving requests. */
    public void start() throws IOException {
        server.start();
        logger.info("Server started, listening on " + port);
        Runtime.getRuntime().addShutdownHook(new Thread() {
        @Override
        public void run() {
            // Use stderr here since the logger may have been reset by its JVM shutdown hook.
            System.err.println("*** shutting down gRPC server since JVM is shutting down");
            try {
            stop();
            } catch (Exception e) {
            e.printStackTrace(System.err);
            }
            System.err.println("*** server shut down");
        }
        });
    }

    /** Stop serving requests and shutdown resources. */
    public void stop() throws InterruptedException {
        if (server != null) {
        server.shutdown().awaitTermination(30, TimeUnit.SECONDS);
        }
    }

    /**
    * Await termination on the main thread since the grpc library uses daemon threads.
    */
    private void blockUntilShutdown() throws InterruptedException, IOException {
        if (server != null) {
        server.awaitTermination();
        }
    }

    /*
        CLIENT
    */
    private Public_ledgerGrpc.Public_ledgerBlockingStub blockingStub;
    public String name;

    public boolean PING(byte[] nodeID) {
        // NodeID request = NodeID.newBuilder().setNodeID("1").build();
        NodeID request = NodeID.newBuilder().setNodeID(new String(nodeID)).setClientName(name).build();
        BooleanSuccessResponse response;
        try {
            response = blockingStub.pING(request);
            System.out.println("Response: " + response.getSuccess());
            return response.getSuccess();
        } catch (StatusRuntimeException e) {
            logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
            return false;
        }
    }

    public void JOIN(NodeInfo request) {
        logger.info("JOIN client side request");
        Kbucket response;
        try {
            response = blockingStub.jOIN(request);
            while (response.getResponse() == false) {
                logger.info("AFTER JOIN client side request");
                logger.info("JOIN returns " + response.getResponse());
                logger.info("replace node, for new id and try new join");
                node = new Node(node.get_Port(), node.get_Ip());
                request = NodeInfo.newBuilder.setNodeID(NodeID.setNodeID(node.getNodeIDStr()).setClientName(name)).setIp(node.get_Ip()).setPort(node.get_Port()).build();
                response = blockingStub.jOIN(request);
            }
            System.out.println("Response: " + response.getResponse());
            // criar kbuckets
            System.out.println("Response: " + response.getBrothers(0));
        } catch (StatusRuntimeException e) {
            logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
            return;
        }
    }

    Binary_tree.Node node = null;
    Thread tserver;

    private void join() {
        
    }

    public void launch() {
        logger.info("Public_ledger launch init");
        // cmdlistener code - importante para debugger
        Thread cmdlistener = new Thread(new Runnable() { 
            @Override
            public void run()
            { 
                try { 
                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
                    String line = "";

                    while (line.equalsIgnoreCase("quit") == false) {
                        line = in.readLine();

                        String[] commands = line.split(" ");

                        if (commands[0].equals("createhardcodednode")) {
                            node = new Binary_tree.Master_node(50051, "127.0.0.1");
                            // preparate server
                            tserver = new Thread(new Runnable() { 
                                @Override
                                public void run()
                                { 
                                    try { 
                                        port = 50051;
                                        server = ServerBuilder.forPort(port).addService(new Public_ledger_Service())
                                            .build();
                                        start();
                                        blockUntilShutdown();
                                    } catch (Exception e) {
                                        e.printStackTrace(); 
                                    }
                                } 
                            });
                            tserver.start();
                        } else if (commands[0].equals("createnode")) {
                            node = new Node(getPort(), "127.0.0.1");
                            //ManagedChannel channel = ManagedChannelBuilder.forTarget("localhost:" + String.valueOf(50051)).usePlaintext().build();
                            //blockingStub = Public_ledgerGrpc.newBlockingStub(channel);
                            name="node:" + node.getNodeIDStr();
                            join();
                            // preparate server
                            tserver = new Thread(new Runnable() { 
                                @Override
                                public void run()
                                { 
                                    try {
                                        port = node.get_Port();
                                        server = ServerBuilder.forPort(port).addService(new Public_ledger_Service())
                                            .build();
                                        start();
                                        blockUntilShutdown();
                                    } catch (Exception e) {
                                        e.printStackTrace(); 
                                    }
                                } 
                            });
                            tserver.start();
                            //JOIN(node.getNodeID());
                        }
                    }

                    in.close();
                } catch (Exception e) { 
                    e.printStackTrace(); 
                }
            } 
        });
        cmdlistener.start();
    }

    public static void main(String[] args) {

        Public_ledger pl = new Public_ledger();
        pl.launch();

    }

    private class Public_ledger_Service extends Public_ledgerGrpc.Public_ledgerImplBase {

        @Override
        public void pING(NodeID request, StreamObserver<BooleanSuccessResponse> responseObserver) {
            System.out.println(request.getClientName() + " has connected");
            String tmpid = request.getNid().getNodeID();

            // updates the appropeiate k-bucket for the sender´s nodeID. 
            // If the sending node already exists in the recipient’s k-bucket, the recipiente moves it to the tail of the list.

            // itera no seu Kbucket
            for(Node no : node.k_bucket.getKbucket())
            {
                if (no.getNodeIDStr().equals(tmpid)) {
                    // already exist
                    responseObserver.onNext(BooleanSuccessResponse.newBuilder().setSuccess(true).build());
                    responseObserver.onCompleted();
                }
            }
            responseObserver.onNext(BooleanSuccessResponse.newBuilder().setSuccess(false).build());
            responseObserver.onCompleted();
        }

        @Override
        public void jOIN(NodeInfo request, StreamObserver<Kbucket> responseObserver) {
        
            System.out.println(request.getNid().getClientName() + " has connected");
            String tmpid = request.getNid().getNodeID();
            Kbucket.Builder kb = Kbucket.newBuilder();
            
            KBucket.ADD = node.k_bucket.add_to_KBucket(new Node(request.getNid().getNodeID().getBytes(), request.getNid().getPort(), request.getNid().getIp()));
            
            if (KBucket.ADD == KBucket.ADD.ADDED)
                // responde com o Kbucket, e faz store nos seus kbuckets e closest
            else if (KBucket.ADD == KBucket.ADD.FULL || KBucket.ADD == KBucket.ADD.OUTOFRANGE) {
                responseObserver.onNext(kb.setResponse(BooleanSuccessResponse.newBuilder().setSuccess(false)).build());
                responseObserver.onCompleted();
            } else if (KBucket.ADD == KBucket.ADD.SPLIT)
                node.k_bucket.split();
                
            responseObserver.onNext(kb.setResponse(BooleanSuccessResponse.newBuilder().setSuccess(false)).build());
            responseObserver.onCompleted();

            // itera no seu Kbucket
            /*
            if (node.k_bucket.getKbucket() != null){
            for(Node no : node.k_bucket.getKbucket())
            {
                if (no.getNodeIDStr().equals(tmpid)) {
                    // already exist
                    responseObserver.onNext(Kbucket.newBuilder().setResponse(BooleanSuccessResponse.newBuilder().setSuccess(false).build()).build());
                    responseObserver.onCompleted();
                }
            }
            }   
            // faz PING para os closest nodes
            if (node.closest != null) {
            for(Node no : node.closest)
            {
                if (no.getNodeIDStr().equals(tmpid)) {
                    // already exist
                    responseObserver.onNext(Kbucket.newBuilder().setResponse(BooleanSuccessResponse.newBuilder().setSuccess(false).build()).build());
                    responseObserver.onCompleted();
                } else {
                    ManagedChannel channel = ManagedChannelBuilder.forTarget(no.get_Ip() + ":" + no.get_PortStr()).usePlaintext().build();
                    blockingStub = Public_ledgerGrpc.newBlockingStub(channel);
                    //String tmpname="node:" + no.getNodeIDStr();
                    if(PING(request.getNid().getNodeID().getBytes())) {
                        // already exist
                        responseObserver.onNext(Kbucket.newBuilder().setResponse(BooleanSuccessResponse.newBuilder().setSuccess(false).build()).build());
                        responseObserver.onCompleted();
                    }
                }
            }
            }
            
            logger.info("Passei a verificação do kbucket do ping");
            // generate response
            Kbucket.Builder kb = Kbucket.newBuilder();
            // itera no seu Kbucket
            if (node.k_bucket.getKbucket() != null){
            for(Node no : node.k_bucket.getKbucket())
            {
                kb.addBrothers(NodeInfo.newBuilder()
                                        .setNid(NodeID.newBuilder()
                                            .setNodeID(no.getNodeIDStr())
                                            .setClientName("id:" + node.getNodeIDStr()))
                                            .setIp(no.get_Ip())
                                            .setPort(no.get_PortStr())
                                        );
            }
            }*/
            //node.k_bucket.add_to_KBucket(new Node(request.getNid().getNodeID().getBytes(), request.getNid().getPort(), request.getNid().getIp()));
            
        }

    }
}